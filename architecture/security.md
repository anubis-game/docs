---
description: >-
  The following steps describe the required onboarding workflow for players to
  enter a new game.
---

# Security

### Deposit

The user's **Wallet** may sign a transaction once in order to deposit tokens into the **Registry** by defining a **Signer**. This dedicated contract write for depositing an available balance allows the user to control their funds at all times, while further game related functionality is delegated to the **Signer**. The **Signer** will later prove that the **Wallet**, **Signer** and **Player** addresses are all controlled by the same entity. The tokens deposited here become the user's available balance within the trustless **Registry** smart contract. The **Signer** is authorized to request participation in a new game via the **Player**, which will then allocate the user's available balance, but only on behalf of the user's **Wallet**. Neither the **Signer** nor the **Player** will ever be able to withdraw user funds from the **Registry**.

```solidity
function deposit(uint256 bal, address sig) public
```

### Request

The **Player** signs a transaction to request participation in a new game by providing the desired **Guardian** address, a threshold timestamp in unix seconds, the associated **Wallet** address, and an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) compliant signature generated by the **Signer**. This contract write will allocated the game specific buy-in amount, which means that the **Player** is spending the available balance of the **Wallet**, but only to the extend of the buy-in amount required for game participation. The success of this contract write proves onchain that the **Wallet** controls the **Signer**, and that the **Signer** controls the **Player**, which in turn proves that the **Wallet** controls the **Player** too. The assumption can then be made that **Wallet**, **Signer** and **Player** are controlled by the same user. As a result of this contract write, a transaction hash will be produced onchain, which will become an input parameter for establishing an authorized WebSocket connection in the next step.&#x20;

```solidity
 function request(address grd, uint64 tim, address wal, bytes memory sgn) public
```

### Connect

The user connects to the **Guardian** to establish an authorized WebSocket connection through which all game state is streamed bidirectionally in realtime. The authorization of this streaming connection happens by providing the successfully submitted transaction hash resulting from the contract write described above, and another [EIP-191](https://eips.ethereum.org/EIPS/eip-191) compliant signature generated by the **Signer**.  It will be the responsibility of the **Guardian** to only accept WebSocket connections if the **Signer** recovered from the first and the second signature is in fact the same address.

```typescript
new WebSocket(
  "wss://guardian.anubis.game/connect", 
  ["dual-handshake", tra, sgn],
);
```

### Signing

For the two required signatures to be considered valid during the dual-handshake, the following criteria must be met. Note that the **Guardian** will access several request specific parameters using the transaction hash provided during the WebSocket authorization process. This applies to the game ID, the unix timestamp, the **Guardian** address and the **Player** address.

* The signed message must be an ordered hyphen joined string.&#x20;
* The first element must either be the string "request" or "connect" respectively.
* The second element must be the desired **Guardian** address.
* The third element must be a valid unix timestamp, which must not be in the future, and must not be older than 60 seconds at the time of requesting game participation.
* The fourth element must be the associated **Player** address.
* The provided signatures must both recover to the same associated **Signer** address.

```typescript
await signMessage(`request-${grd}-${tim}-${pla}`); // Registry request onchain
await signMessage(`connect-${grd}-${tim}-${pla}`); // Guardian connect offchain
```
