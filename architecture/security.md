---
description: >-
  The following steps describe the required onboarding workflow for players to
  enter a new game.
---

# Security

### Deposit

```solidity
function deposit(uint256 tokens, address player) public
```

The user's **Wallet** may sign a transaction once in order to deposit tokens into the **Registry** by defining the **Player** as delegate. This allows the user to control their funds at all times, while only having to sign transactions during deposits and withdrawals. That is a key UX element of the onboarding workflow described here. The **Player** delegation will then also prove that the **Wallet** and the **Player** are controlled by the same entity, as soon as the **Player** signs a transaction to enter a new game. The tokens deposited here become the user's available balance within the **Registry** smart contract. The **Player** is authorized to enter games with that available balance, but only on behalf of the user's **Wallet**. The **Player** will never be able to withdraw user funds from the **Registry**.

### Request

```solidity
 function request(uint256 game, uint64 timestamp, bytes memory signature) public
```

The **Player** signs a transaction to request participation in a new game by providing the desired game ID, a threshold timestamp in unix seconds, and an [EIP-191](https://eips.ethereum.org/EIPS/eip-191) compliant signature generated by the **Signer**. Should the contract write to this request function succeed, it has then be proven onchain, that the **Wallet** owns the **Player**, and that the **Player** owns the **Signer**. And that in turn means then that the **Wallet** owns the **Signer** too. The assumption can then be made that **Wallet**, **Signer** and **Player** are controlled by the same entity. As a result of this contract write, a transaction hash will be produced onchain, which will become an input parameter in order to establish an authorized WebSocket connection in the next step.&#x20;

### Connect

```typescript
new WebSocket(
  "wss://guardian.anubis.game/connect", 
  ["dual-handshake", wallet, transaction, signature],
);
```

The **Wallet** connects to the **Guardian** to establish an authorized WebSocket connection through which all game state is streamed bidirectionally in realtime. The authorization of this streaming connection happens by providing the associated **Wallet** address, the transaction hash resulting from the contract write described above, and another [EIP-191](https://eips.ethereum.org/EIPS/eip-191) compliant signature generated by the **Signer**.  It will be the responsibility of the **Guardian** to only accept WebSocket connections if the **Signer** recovered from the first and the second signature is in fact the same address.

### Signing

```typescript
await signMessage(`registry-${game}-${timestamp}-${wallet}`); // request onchain
await signMessage(`guardian-${game}-${timestamp}-${wallet}`); // connect offchain
```

For the two provided signatures to be considered valid during the dual-handshake, the following criteria must be met.

* The signed message must be a hyphen joined string of the following order. First, the string "registry" or "guardian" respectively. Second, the desired game ID. Third, a valid unix timestamp. Fourth, the associated **Wallet** address.
* The provided unix timestamp must not be older than 5 minutes at the time of requesting game participation. Note that the Guardian will access the unix timestamp using the transaction hash provided during the WebSocket authorization. The same is true for the game ID.
* The used **Wallet** must be the address that delegated to the caller that is signing the transaction for the request function call. That delegate is the **Player** acting on behalf of the **Wallet**. Note that the **Registry** will access the **Wallet** address using the **Player** mapping established during the deposit contract write.
* The provided signatures must both recover to the same associated **Signer** address.



